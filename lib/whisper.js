// Generated by CoffeeScript 1.6.2
(function() {
  var AGGREGATES, ARCHIVE_SIZE, File, METADATA_SIZE, POINT_SIZE, Path, Whisper, glob;

  File = require("fs");

  Path = require("path");

  glob = require("glob");

  ARCHIVE_SIZE = 12;

  METADATA_SIZE = 16;

  POINT_SIZE = 12;

  AGGREGATES = {
    1: "average",
    2: "sum",
    3: "last",
    4: "max",
    5: "min"
  };

  Whisper = (function() {
    function Whisper(basedir) {
      if (basedir == null) {
        basedir = "/opt/graphite/storage";
      }
      this.basedir = Path.normalize(basedir);
      this.metrics = {};
    }

    Whisper.prototype.index = function(callback) {
      var path,
        _this = this;

      path = "" + this.basedir + "/whisper/";
      return glob("" + path + "**/*.wsp", function(error, matches) {
        var match, names;

        if (error) {
          return callback(error);
        }
        names = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = matches.length; _i < _len; _i++) {
            match = matches[_i];
            _results.push(match.slice(path.length).replace(/\.wsp$/, "").replace(/\//g, "."));
          }
          return _results;
        })();
        return callback(null, names);
      });
    };

    Whisper.prototype.find = function(fqn, callback) {
      var next_part;

      next_part = function(parts, index, path, callback) {
        var part;

        part = parts[index];
        if (part === "") {
          callback(null, []);
        }
        if (index === parts.length - 1) {
          if (part[part.length - 1] === "*") {
            part = part.slice(0, part.length - 1);
            return Path.exists(path, function(exists) {
              if (!exists) {
                return callback(null, []);
              }
              return File.readdir(path, function(error, filenames) {
                var candidates, fn, next_match;

                if (error) {
                  return callback(error);
                }
                candidates = (function() {
                  var _i, _len, _results;

                  _results = [];
                  for (_i = 0, _len = filenames.length; _i < _len; _i++) {
                    fn = filenames[_i];
                    if (fn.slice(0, part.length) === part && fn.slice(-4) === ".wsp") {
                      _results.push(Path.basename(fn, ".wsp"));
                    }
                  }
                  return _results;
                })();
                next_match = function(i, matches) {
                  var match;

                  if (i === candidates.length) {
                    return callback(null, matches);
                  } else {
                    match = candidates[i];
                    return File.stat("" + path + "/" + (match.replace(/\./g, "/")) + ".wsp", function(error, stat) {
                      if (error) {
                        return callback(error);
                      }
                      if (stat.isFile()) {
                        return next_match(i + 1, matches.concat(parts.slice(0, index).concat(match).join(".")));
                      } else {
                        return next_match(i + 1, matches);
                      }
                    });
                  }
                };
                return next_match(0, []);
              });
            });
          } else {
            return callback(null, [parts.join(".")]);
          }
        } else if (part[part.length - 1] === "*") {
          part = part.slice(0, part.length - 1);
          return Path.exists(path, function(exists) {
            if (!exists) {
              return callback(null, []);
            }
            return File.readdir(path, function(error, filenames) {
              var fn, matches, next_sibling;

              if (error) {
                return callback(error);
              }
              matches = (function() {
                var _i, _len, _results;

                _results = [];
                for (_i = 0, _len = filenames.length; _i < _len; _i++) {
                  fn = filenames[_i];
                  if (fn.slice(0, part.length) === part) {
                    _results.push(fn);
                  }
                }
                return _results;
              })();
              next_sibling = function(all) {
                var clone, match;

                match = matches.shift();
                if (match) {
                  clone = parts.slice();
                  clone[index] = match;
                  return next_part(clone, index + 1, "" + path + "/" + match, function(error, metrics) {
                    if (error) {
                      return callback(error);
                    }
                    return next_sibling(all.concat(metrics));
                  });
                } else {
                  return callback(null, all);
                }
              };
              return next_sibling([]);
            });
          });
        } else {
          return next_part(parts, index + 1, "" + path + "/" + part, callback);
        }
      };
      return next_part(fqn.split("."), 0, "" + this.basedir + "/whisper", callback);
    };

    Whisper.prototype.metric = function(fqn, from_time, until_time, callback) {
      var fd, filename,
        _this = this;

      fd = this.metrics[fqn];
      if (fd) {
        return Whisper.points(fd, from_time, until_time, callback);
      } else {
        filename = "" + this.basedir + "/whisper/" + (fqn.replace(/\./g, "/")) + ".wsp";
        return Path.exists(filename, function(exists) {
          if (exists) {
            return File.open(filename, "r", function(error, fd) {
              if (error) {
                return callback(error);
              }
              _this.metrics[fqn] = fd;
              return Whisper.points(fd, from_time, until_time, callback);
            });
          } else {
            return callback(new Error("No metric " + fqn));
          }
        });
      }
    };

    return Whisper;

  })();

  Whisper.header = function(fd, callback) {
    var metadata;

    metadata = new Buffer(METADATA_SIZE);
    return File.read(fd, metadata, 0, METADATA_SIZE, 0, function(error) {
      var aggregate, max_retention, next, remain, xff;

      if (error) {
        return callback(error);
      }
      aggregate = metadata.readInt32BE(0);
      max_retention = metadata.readInt32BE(4);
      xff = metadata.readFloatBE(8);
      remain = metadata.readInt32BE(12);
      next = function(remain, archives) {
        var header, packed, pos;

        if (remain) {
          packed = new Buffer(ARCHIVE_SIZE);
          pos = METADATA_SIZE + ARCHIVE_SIZE * archives.length;
          return File.read(fd, packed, 0, ARCHIVE_SIZE, pos, function(error) {
            var archive, offset, points, sec_per_point;

            if (error) {
              return callback(error);
            }
            offset = packed.readInt32BE(0);
            sec_per_point = packed.readInt32BE(4);
            points = packed.readInt32BE(8);
            archive = {
              offset: offset,
              sec_per_point: sec_per_point,
              points: points,
              retention: sec_per_point * points,
              size: points * POINT_SIZE
            };
            return next(remain - 1, archives.concat(archive));
          });
        } else {
          header = {
            aggregate: AGGREGATES[aggregate],
            max_retention: max_retention,
            xff: xff,
            archives: archives
          };
          return callback(null, header);
        }
      };
      return next(remain, []);
    });
  };

  Whisper.points = function(fd, from_time, until_time, callback) {
    return Whisper.header(fd, function(error, header) {
      var archive, base, diff, from_interval, now, oldest_time, points, step, time_info, until_interval, _i, _len, _ref;

      if (error) {
        return callback(error);
      }
      now = Math.floor(Date.now() / 1000);
      if (until_time == null) {
        until_time = now;
      }
      oldest_time = now - header.max_retention;
      if (from_time < oldest_time) {
        from_time = oldest_time;
      }
      if (!(from_time < until_time)) {
        callback(Error("Invalid time interval"));
        return;
      }
      if (until_time > now) {
        until_time = now;
      }
      if (until_time < from_time) {
        until_time = now;
      }
      archive = null;
      diff = now - from_time;
      _ref = header.archives;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        archive = _ref[_i];
        if (archive.retention >= diff) {
          break;
        }
      }
      if (!archive) {
        callback(null);
        return;
      }
      step = archive.sec_per_point;
      from_interval = Math.floor(from_time - (from_time % step)) + step;
      until_interval = Math.floor(until_time - (until_time % step)) + step;
      points = (until_interval - from_interval) / step;
      time_info = {
        aggregate: header.aggregate,
        from: from_interval,
        step: step,
        until: until_interval
      };
      base = new Buffer(POINT_SIZE);
      return File.read(fd, base, 0, POINT_SIZE, archive.offset, function(error) {
        var archive_end, base_interval, byte_distance, from_offset, head, point_distance, results, series, tail, time_distance, until_offset;

        if (error) {
          return callback(error);
        }
        base_interval = base.readInt32BE(0);
        if (base_interval === 0) {
          callback(null, time_info, new Array(points));
          return;
        }
        time_distance = from_interval - base_interval;
        point_distance = Math.floor(time_distance / step);
        byte_distance = point_distance * POINT_SIZE + archive.size;
        from_offset = archive.offset + (byte_distance % archive.size);
        time_distance = until_interval - base_interval;
        point_distance = Math.floor(time_distance / step);
        byte_distance = point_distance * POINT_SIZE + archive.size;
        until_offset = archive.offset + (byte_distance % archive.size);
        if (from_offset < until_offset) {
          series = new Buffer(until_offset - from_offset);
          File.read(fd, series, 0, series.length, from_offset, function(error) {
            if (error) {
              return callback(error);
            }
            return results(series, from_interval);
          });
        } else {
          archive_end = archive.offset + archive.size;
          tail = archive_end - from_offset;
          head = until_offset - archive.offset;
          series = new Buffer(tail + head);
          File.read(fd, series, 0, tail, from_offset, function(error) {
            if (error) {
              return callback(error);
            }
            return File.read(fd, series, tail, head, archive.offset, function(error) {
              if (error) {
                return callback(error);
              }
              return results(series, from_interval);
            });
          });
        }
        return results = function(series, from_time) {
          var i, index, max, min, point_time, value, values, _j;

          points = series.length / POINT_SIZE;
          values = new Array(points);
          min = max = void 0;
          for (i = _j = 0; 0 <= points ? _j < points : _j > points; i = 0 <= points ? ++_j : --_j) {
            point_time = series.readInt32BE(i * POINT_SIZE);
            if (!(point_time > from_time)) {
              continue;
            }
            index = (point_time - from_time) / step;
            if (index < points) {
              value = series.readDoubleBE(i * POINT_SIZE + 4);
              values[index] = value;
              if (min === void 0 || value < min) {
                min = value;
              }
              if (max === void 0 || value > max) {
                max = value;
              }
            }
          }
          time_info.min = min;
          time_info.max = max;
          return callback(null, time_info, values);
        };
      });
    });
  };

  module.exports = Whisper;

}).call(this);
