// Generated by CoffeeScript 1.6.2
(function() {
  var FUNCTIONS, File, PEG, RequestContext, Series, assert, grammer, parser,
    __slice = [].slice;

  assert = require("assert");

  File = require("fs");

  PEG = require("pegjs");

  FUNCTIONS = require("./functions");

  Series = require("./series");

  grammer = File.readFileSync("" + __dirname + "/grammer.pegjs", "utf8");

  parser = PEG.buildParser(grammer);

  RequestContext = (function() {
    function RequestContext(_arg) {
      var from, to, width;

      this.whisper = _arg.whisper, from = _arg.from, to = _arg.to, width = _arg.width;
      assert(width, "Argument width is required");
      to = Math.floor(to || (Date.now() / 1000));
      from = Math.floor(from || (to - 60 * width));
      assert(from < to, "Invalid time range, from less than to");
      this.sec_per_point = Math.floor((to - from) / width);
      this.sec_per_point || (this.sec_per_point = 1);
      this.to = to - to % this.sec_per_point;
      this.from = to - width * this.sec_per_point;
      this.points_count = Math.floor((this.to - this.from) / this.sec_per_point);
      this.metrics = {};
    }

    RequestContext.prototype.evaluate = function(targets, callback) {
      var next_result,
        _this = this;

      if (!Array.isArray(targets)) {
        targets = [targets];
      }
      next_result = function(i, results) {
        var target;

        if (i === targets.length) {
          return process.nextTick(function() {
            var datapoints, j, next, series, time, value, _i, _ref;

            targets = new Array(results.length);
            for (i in results) {
              series = results[i];
              datapoints = new Array(_this.points_count);
              time = _this.from;
              for (j = _i = 0, _ref = _this.points_count; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
                next = time + _this.sec_per_point;
                value = series.valueAt(time, next);
                datapoints[j] = [value, time];
                time = next;
              }
              targets[i] = {
                target: series.name,
                datapoints: datapoints
              };
            }
            return callback(null, targets);
          });
        } else {
          console.log("Evaluating " + targets[i]);
          target = parser.parse(targets[i], "target");
          return _this._evaluateTarget(target, function(error, result) {
            return process.nextTick(function() {
              if (error) {
                return callback(error);
              } else {
                return next_result(i + 1, results.concat(result));
              }
            });
          });
        }
      };
      return next_result(0, []);
    };

    RequestContext.prototype._evaluateTarget = function(expression, callback) {
      if (expression.hasOwnProperty("series")) {
        return this.get(expression.series, callback);
      } else if (expression.hasOwnProperty("function")) {
        return this._evaluateFunction(expression["function"], expression.args, callback);
      } else {
        return callback(new Error("Don't understand the expression " + expression));
      }
    };

    RequestContext.prototype._evaluateFunction = function(fn_name, args, callback) {
      var fn, next_arg,
        _this = this;

      fn = FUNCTIONS[fn_name];
      if (!fn) {
        callback(new Error("No function " + fn_name));
        return;
      }
      next_arg = function(i, values) {
        var error, results;

        if (i === args.length) {
          try {
            results = fn.apply(null, [_this].concat(__slice.call(values)));
            if (!Array.isArray(results)) {
              results = [results];
            }
            return process.nextTick(function() {
              return callback(null, results);
            });
          } catch (_error) {
            error = _error;
            return callback(error);
          }
        } else {
          return _this._evaluateArgument(args[i], function(error, value) {
            if (error) {
              return callback(error);
            }
            return next_arg(i + 1, values.concat(value));
          });
        }
      };
      return next_arg(0, []);
    };

    RequestContext.prototype._evaluateArgument = function(expression, callback) {
      if (expression.hasOwnProperty("number")) {
        return callback(null, expression.number);
      } else if (expression.hasOwnProperty("string")) {
        return callback(null, expression.string);
      } else if (expression.hasOwnProperty("series")) {
        return this.get(expression.series, callback);
      } else if (expression.hasOwnProperty("function")) {
        return this._evaluateFunction(expression["function"], expression, args, callback);
      } else {
        return callback(new Error("Don't understand the expression " + expression));
      }
    };

    RequestContext.prototype.get = function(glob, callback) {
      var _this = this;

      return this.whisper.find(glob, function(error, names) {
        var next_metric;

        if (error) {
          return callback(error);
        }
        if (names.length === 0) {
          return callback(new Error("No metrics found for " + glob));
        } else {
          next_metric = function(i, results) {
            var metric, name;

            if (i === names.length) {
              return process.nextTick(function() {
                return callback(null, results);
              });
            } else {
              name = names[i];
              metric = _this.metrics[name];
              if (metric) {
                return next_metric(i + 1, results.concat(metric));
              } else {
                return _this.whisper.metric(name, _this.from, _this.to, function(error, time_info, datapoints) {
                  var options, series;

                  if (error) {
                    return callback(error);
                  }
                  options = {
                    name: name,
                    from: time_info.from,
                    to: time_info.until,
                    sec_per_point: time_info.step,
                    datapoints: datapoints
                  };
                  series = new Series(options);
                  _this.metrics[name] = series;
                  return next_metric(i + 1, results.concat(series));
                });
              }
            }
          };
          return next_metric(0, []);
        }
      });
    };

    RequestContext.prototype.constant = function(value) {
      var series;

      series = {
        valueAt: function() {
          return value;
        },
        name: value
      };
      return series;
    };

    RequestContext.prototype.combine = function() {
      var args, combinator, combined, name, series;

      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      combinator = args.pop();
      combined = function(time) {
        var j, values, _i, _len;

        values = new Array(args.length);
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          j = args[_i];
          values[j] = args[i](time);
        }
        return combinator(values);
      };
      combined.toString = function() {
        return name;
      };
      series = {
        valueAt: function(from, to) {},
        name: name
      };
      return series;
    };

    RequestContext.prototype.average_series = function(series) {
      var count, sum, time, value, _i, _ref, _ref1, _ref2;

      count = 0;
      sum = 0;
      for (time = _i = _ref = this.from, _ref1 = this.to, _ref2 = this.sec_per_point; _ref2 > 0 ? _i < _ref1 : _i > _ref1; time = _i += _ref2) {
        value = series.valueAt(time, time + this.sec_per_point);
        if (value !== void 0) {
          sum += value;
          ++count;
        }
      }
      if (count > 0) {
        return sum / count;
      }
    };

    return RequestContext;

  })();

  module.exports = RequestContext;

}).call(this);
